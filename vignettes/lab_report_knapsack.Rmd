---
title: "lab_report_knapsack"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{lab_report_knapsack}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This package can calculate the knapsack problem in 3 ways:brute_force_knapsack, knapsack_dynamic and greedy_knapsack.At the same time, some optimization methods to improve code performance are also introduced.

# Load packages

```{r setup}
library(KpRpkg)
```

# Brute_force_search

Using brute_force_search to solve the knapsack problem can refer to the following example.First, We generate the data in the following way:

```{r knapsack_objects}
RNGversion(min(as.character(getRversion()),"3.5.3"))
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
n <- 2000
knapsack_objects <- data.frame(
  w=sample(1:4000, size = n, replace = TRUE),
  v=runif(n = n, 0, 10000)
)
```

brute_force_knapsack:

```{r brute_force_search}
resultA <- brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
print(resultA)
```

We can also know the performance of the program execution:

```{r system_time_brute_force_search}
timeA <- system.time({
  result <- brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500)
})
print(timeA)
```

This result will show that the brute_force_knapsack execution time is around 0.22S when n=16 and W=3500.

# knapsack_dynamic

```{r knapsack_dynamic}
resultB <- knapsack_dynamic(x = knapsack_objects[1:8,], W = 3500)
print(resultB)
```

We can also know the performance of the program execution:

```{r system_time_knapsack_dynamic}
timeB <- system.time({
  result <- knapsack_dynamic(x = knapsack_objects[1:500,], W = 3500)
})
print(timeB)
```

This result will show that the knapsack_dynamic execution time is around 2.60S when n=500 and W=3500.

# greedy_knapsack

```{r greedy_knapsack}
resultc <- greedy_knapsack(x = knapsack_objects[1:800,], W = 3500)
print(resultc)
```

We can also know the performance of the program execution:

```{r system_time_greedy_knapsack}
set.seed(42)
n <- 1000000
W <- 2000000
knapsack_objects <- data.frame(
  w = sample(1:4000, size = n, replace = TRUE), 
  v = runif(n = n, 0, 10000)
)
timeC <- system.time({
  result <- greedy_knapsack(x = knapsack_objects, W = W)
})
print(timeC)
```

This result will show that the knapsack_dynamic execution time is around 1.23S when n=1000000 and W=2000000.

# Profile your code and optimize your code

The content of this section is discussed by the package profvis to identify bottlenecks, and optimized in the following aspects: pre-allocation of memory, calculation of value ratio and sorting, index use. These optimizations allow functions to handle larger data sets with fewer unnecessary operations and to preallocate memory with reasonable data structures, thereby improving performance.

```{r greedy_knapsack_optimized}
library(profvis)
set.seed(42)
n <- 1000000
W <- 2000000
knapsack_objects <- data.frame(
  w = sample(1:4000, size = n, replace = TRUE),
  v = runif(n = n, 0, 10000)
)
profvis({
  result <- greedy_knapsack_optimized(x = knapsack_objects, W)
  print(result)
})
```

Profvis shows that the execution time of the optimized function is 60ms shorter than that before optimization.

# Parallelize_brute_force_search

```{r parallel_brute_force_knapsack}
resultd <- parallel_brute_force_knapsack(x = knapsack_objects[1:22,], W = 3500,parallel = FALSE)
timed <- system.time({
  result <- parallel_brute_force_knapsack(x = knapsack_objects[1:22,], W = 3500,parallel = FALSE)
})
print(resultd)
print(timed)
```

By introducing parallel computation, the function is able to reduce computation time and improve efficiency when dealing with large data sets, which is particularly important for brute_force_knapsack algorithms, because its time complexity increases rapidly with the number of items.In this example, when n=22 and W=3500, the execution time of the original brute_force_knapsack is about 14.6 seconds, and the execution time of the parallel_brute_force_knapsack is about 10 seconds(you should set: parallel = TRUE).